## 목표:
C언어로 작성한 소스코드를 실행하면 변수가 어떤 과정으로 주기억장치에 저장되고 사용되는지 알아본다.

## 본문:

### 용어정리:
1. 컴파일러(Compiler): 개발자가 작성한 소스코드(개발언어)를 컴퓨터가 이해할 수 있는 기계어(바이너리)코드로 변환하는 일종의 번역기.
2. 목적 코드(Object code): 컴파일러에 의해 생성된 코드.
3. 컴파일 타임: 컴파일러에 의해 개발언어가 목적 코드로 변환되는 과정.
4. 런 타임: 프로그램이 실행되는 때를 의미.
5. 프로세스: 실행되고 있는 프로그램
6. [가상 메모리(Virtual[logical] memory)](#참고)	&#91;1&#93;: 
각 프로세스마다 주기억장치 내의 고유한 메모리 공간을 필요로 한다. 하지만 OS는 멀티 프로세스를 지원하는데 주기억장치는 여러 개의 프로세스를 온전히 실행하기에 충분한 공간을 가지고 있지 않다. 따라서 이를 보완하기 위해 하드디스크(HDD) 내의 공간을 주기억장치의 공간 대신 할당하여 마치 주기억장치 내의 메모리가 할당된 것 처럼 속이는데 이때 프로세스에 주어진 메모리를 가상 메모리라고 한다.
7. 상대 주소: 절대 주소와 달리 상대적인 기준에 맞춰 표현하기 위한 임시 주소. 
ex) 0 부터 60000 까지 상대주소로 설정한다. 이 주소가 추후 실제 주기억장치의 100000번에 위치한 물리주소를 기준으로 
100000 부터 160000 까지로 변경 될 수 있다. 
8. 가상 주소 공간(Virtual address space)(#참고) &#91;2&#93;: 말 그대로 가상의 주소 공간으로 프로세스가 참조할 수 있는 주소 범위이다. 이 주소 공간은 프로그램이 실행될 때 실행파일이 가지고 있는 상대 주소를 기준으로 OS에 의해 생성되며 Hdd 내에 저장된다. - 실행 시점 바인딩 (이 공간은 코드, 데이터, 힙, 스텝 영역으로 나뉜다)
9. 페이지: 가상 주소 공간을 일정한 크기로 나눈 블록.
10. 프레임: 주기억장치 공간(실제 물리 주소)을 일정한 크기로 나눈 블록. ( 페이지와 같은 크기이다. ) 
11. [페이징](#참고)&#91;3&#93;: 남는 공간 없이 주기억장치 메모리를 관리하기 위해 고안된 기법이다. [링크 참고](#참고)&#91;3&#93;
12. 디멘드 페이징: 프로세스가 실제로 필요로하는 페이지들만 주기억장치에 저장하는 기법. 
13. 페이지 테이블: 가상메모리의 페이지들을 관리하는 테이블로, 필요한 가상주소에 해당하는 페이지 넘버가 저장돼있다. MMU는 이 페이지테이블을 사용하여 가상주소와 연결된 페이지 주소를 빠르게 파악한다. 또한 프레임에 올라간 페이지들을 표기하여 새로운 데이터 요청이 들어왔을 때 이미 
프레임에 올라간 페이지인지 아닌지 파악하는 지표로 사용된다.
14. MMU(Memory Management Unit): 가상 공간에 있는 요청 데이터를 주기억장치로 옮기고 반대로 필요없는 데이터를 내리는 역할을 담당하는 CPU의 내장장치.
### 컴파일 타임동안 일어나는 과정(변수의 쓰임을 기준으로)
1. 컴파일러는 컴파일 타임동안 각 변수의 크기를 파악한다.(필요한 메모리 크기 파악)
2. 컴파일러는 컴파일 타임동안 각 변수에 해당하는 상대주소(가상주소)를 생성한다.(
3. 실행파일내에 가상주소가 포함된다.
4. 런타임시 프로세스는 가상 주소 공간에 포함되는 모든 변수를 필요로하지 않는다. 따라서 주기억장치 공간에는 해당 프로세스가 필요하는 데이터가 속한 페이지들만 프레임으로 저장한다.(디멘드 페이징)  
"4번 과정 설명"  
4-1. CPU가 필요한 데이터의 가상 주소를 MMU에게 넘겨주면 페이지 테이블에서 가상 주소에 해당하는 페이지가 존재하는지 찾는다. 
4-2. 페이지가 있다면 그 페이지의 상태를 확인하고 프레임에 올라가있지 않은 페이지의 경우 프레임 공간을 확보하여 적절한 곳에 저장한다.
4-3. 페이지가 없다면 MMU는 가상 주소 공간(hdd)에서 찾은 후 그 값을 페이지 테이블에 저장한다. 
5. 주기억장치의 공간이 가득 찼을 경우, 필요없는 프레임을 삭제하고 요청된 프레임을 저장한다.

### 결론:
C언어의 지역함수를 가리키는 포인터를 리턴하여 외부에서 그 포인터에 존재하는 값을 확인하면 여전히 남아있는 것을 보고 왜 지역변수가 할당해제되지 않고 여전히 데이터가 남아있는지 궁금해서 이 공부를 시작했다. 결과적으로 아직 왜 이런지 확실하게 알아내지는 못했고 메모리 구조와 쓰임에 대해 학습하는 시간이 되었다. 몇 가지 자료들을 읽으며 추측할 수 있는 것은, 첫 번째로 MMU는 메모리를 null이나 쓰레기 값으로 초기화할 의무가 없기 때문에 주기억장치에 저장된 데이터가 할당 해제되더라도 초기화 하지 않은면 해당 주소에 데이터가 남아 있을 수 있다. 그래서 Pointer로 주소에 접근시 여전시 데이터가 남아있다. 하지만 동적할당 이후 free를 하면 주소에 접근 자체가 안된다. 이 둘의 차이점을 더 알아봐야 이 궁금증이 해결될 것 같다.
두 번째로는 어떠한 이유로 외부함수에서 내부함수를 여전히 사용하고 있을 경우에 마치 클로저처럼 지역변수가 여전히 남아있다는 것이다. 
이 부분들은 생각보다 시간이 오래걸릴 듯 하여 나중에 C언어를 공부할 필요가 있을 때 다시 살펴보려고 한다. 

### 다음 공부 자료:
가비지 콜렉터

##### 참고
- &#91;1&#93;[가상메모리](https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC)  
- &#91;2&#93;[가상 주소 공간](https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EC%A3%BC%EC%86%8C_%EA%B3%B5%EA%B0%84)  
- &#91;2&#93;[페이징](https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95)  
- [What does "Memory allocated at compile time" really mean?](https://stackoverflow.com/questions/21350478/what-does-memory-allocated-at-compile-time-really-mean)  
- [Virtual address space](https://en.wikipedia.org/wiki/Virtual_address_space)  
- [Mapping Virtual Addresses  to Physical Addresses](https://www.geeksforgeeks.org/mapping-virtual-addresses-to-physical-addresses/)
- [How does compiler lay out code in memory](https://stackoverflow.com/questions/19101449/how-does-compiler-lay-out-code-in-memory#:~:text=Each%20program%20is%20compiled%2Flinked,where%20virtual%20memory%20comes%20in.&text=This%20virtual%20address%20space%20is,space%20and%20user%20addressable%20space.) 
- [운영체제 MMU...](https://about-myeong.tistory.com/35)  
- [프로세스와 가상 메모리](https://brownbears.tistory.com/47)  
- [access memory](https://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope/6445794#6445794)
